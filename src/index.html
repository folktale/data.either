<!DOCTYPE html><html lang="en"><head><title>src/index</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/index"><meta name="groc-project-path" content="src/index.ls"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Arvo|PT+Sans"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/index.ls</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><h1 id="monad-eithera-b">Monad: Either(a, b)</h1>

<p>The <code>Either(a, b)</code> monad represents the logical disjunction between
<code>a</code> and <code>b</code>. In other words, <code>Either</code> may contain either a value of
type <code>a</code> or a value of type <code>b</code>, at any given time. This particular
implementation is biased on the right value (<code>b</code>), thus projections
will take the right value over the left one.</p></div></div></div><div class="segment"><div class="code folded"><div class="wrapper marker"><span class="c1">/** </span></div><div class="wrapper"><span class="cm">/** </span>
<span class="cm"> * Copyright (c) 2013 Quildreen Motta</span>
<span class="cm"> *</span>
<span class="cm"> * Permission is hereby granted, free of charge, to any person</span>
<span class="cm"> * obtaining a copy of this software and associated documentation files</span>
<span class="cm"> * (the &quot;Software&quot;), to deal in the Software without restriction,</span>
<span class="cm"> * including without limitation the rights to use, copy, modify, merge,</span>
<span class="cm"> * publish, distribute, sublicense, and/or sell copies of the Software,</span>
<span class="cm"> * and to permit persons to whom the Software is furnished to do so,</span>
<span class="cm"> * subject to the following conditions:</span>
<span class="cm"> *</span>
<span class="cm"> * The above copyright notice and this permission notice shall be</span>
<span class="cm"> * included in all copies or substantial portions of the Software.</span>
<span class="cm"> *</span>
<span class="cm"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="cm"> * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="cm"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND</span>
<span class="cm"> * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE</span>
<span class="cm"> * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION</span>
<span class="cm"> * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION</span>
<span class="cm"> * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="cm"> */</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>This class models two different cases: <code>Left a</code> and <code>Right b</code>, and can
hold one of the cases at any given time. The projections are, none the
less, biased for the <code>Right</code> case, thus a common use case for this
monad is to hold the results of computations that may fail, when you
want to store additional information on the failure (instead of
throwing an exception).</p>

<p>Furthermore, the values of <code>Either(a, b)</code> can be combined and
manipulated by using the expressive monadic operations. This allows
safely sequencing operations that may fail, and safely composing
values that you don't know whether they're present or not, failing
early (returning a <code>Left a</code>) if any of the operations fail.</p>

<p>While this class can certainly model input validations, the
<a href="https://github.com/folktale/data.validation">Validation</a> monad lends itself better to that use case, since it
can naturally aggregate failures — monads shortcut on the first
failure.</p></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="class-eithera-b">Class: Either(a, b)</h2>

<p>The <code>Either(a, b)</code> monad.</p>

<ul>
<li>type: Either(a, b) &lt;: Applicative, Functor, Chain, Show, Eq</li>
</ul></div></div><div class="code"><div class="wrapper"><span class="k">class</span> <span class="nx">Either</span>
  <span class="nf">-&gt;</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="constructors">Constructors</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-left">Function: Left</h4>

<p>Constructs a new <code>Either(a, b)</code> monad holding a <code>Left</code> value. This
usually represents a failure due to the right-bias of this monad.</p>

<ul>
<li>type: a -> Either(a, b)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">Left: </span><span class="nf">(a) -&gt;</span> <span class="k">new</span> <span class="nx">Left</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-right">Function: Right</h4>

<p>Constructs a new <code>Either(a, b)</code> monad holding a <code>Right</code> value. This
usually represents a successful value due to the right-bias of this
monad.</p>

<ul>
<li>type: b -> Either(a, b)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">Right: </span><span class="nf">(b) -&gt;</span> <span class="k">new</span> <span class="nx">Right</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-from-nullable">Function: from-nullable</h4>

<p>Constructs a new <code>Either(a, b)</code> from a nullable type. Takes the
<code>Left</code> case if the value is <code>null</code> or <code>undefined</code>. Takes the <code>Right</code>
case otherwise.
+ type: a -> Either(a, a)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">from-nullable: </span><span class="nf">(a) -&gt;</span>
    <span class="o">|</span> <span class="nx">a</span><span class="o">?</span> <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">Right</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
    <span class="o">|</span> <span class="nx">_</span>  <span class="o">=&gt;</span> <span class="k">new</span> <span class="nx">Left</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="predicates">Predicates</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="field-is-left">Field: is-left</h4>

<p>True if the <code>Either(a, b)</code> contains a <code>Left</code> value.
+ type: Boolean</p></div></div><div class="code"><div class="wrapper">  <span class="o">is-</span><span class="nv">left: </span><span class="kc">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="field-is-right">Field: is-right</h4>

<p>True if the <code>Either(a, b)</code> contains a <code>Right</code> value.
+ type: Boolean</p></div></div><div class="code"><div class="wrapper">  <span class="o">is-</span><span class="nv">right: </span><span class="kc">false</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="applicative">Applicative</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-of">Function: of</h4>

<p>Creates a new <code>Either(a, b)</code> instance holding the <code>Right</code> value
<code>b</code>.</p>

<p><code>b</code> can be any value, including <code>null</code>, <code>undefined</code> or another
<code>Either(a, b)</code> monad.</p>

<ul>
<li>type: b -> Either(a, b)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="k">of</span><span class="o">:</span> <span class="nf">(b) -&gt;</span> <span class="k">new</span> <span class="nx">Right</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-ap">Function: ap</h4>

<p>Applies the function inside the <code>Right</code> case of the <code>Either(a, b)</code>
monad to another applicative type.
The <code>Either(a, b)</code> monad should contain a function value, otherwise
a <code>TypeError</code> is thrown.
+ type: (@Either(a, b -> c), f:Applicative) => f(b) -> f(c)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">ap: </span><span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="functor">Functor</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-map">Function: map</h4>

<p>Transforms the <code>Right</code> value of the <code>Either(a, b)</code> monad using a
regular unary function.</p>

<ul>
<li>type: (@Either(a, b)) => (b -> c) -> Either(a, c)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">map: </span><span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="chain">Chain</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-chain">Function: chain</h4>

<p>Transforms the <code>Right</code> value of the <code>Either(a, b)</code> monad using an
unary function to a monad of the same type.</p>

<ul>
<li>type: (@Either(a, b)) => (b -> Either(a, c)) -> Either(a, c)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">chain: </span><span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="show">Show</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-to-string">Function: to-string</h4>

<p>Returns a textual representation of the <code>Either(a, c)</code> monad.</p>

<ul>
<li>type: (@Either(a, b)) => Unit -> String</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="k">to</span><span class="o">-</span><span class="nv">string: </span><span class="nf">-&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="eq">Eq</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-is-equal">Function: is-equal</h4>

<p>Tests if an <code>Either(a, b)</code> monad is equal to another <code>Either(a, b)</code>
monad.
+ type: (@Either(a, b)) => Either(a, b) -> Boolean</p></div></div><div class="code"><div class="wrapper">  <span class="o">is-</span><span class="nv">equal: </span><span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="extracting-and-recovering">Extracting and Recovering</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-get">Function: get</h4>

<p>Extracts the <code>Right</code> value out of the <code>Either(a, b)</code> monad, if it
exists. Otherwise throws a <code>TypeError</code>.</p>

<ul>
<li>see: get-or-else — A getter that can handle failures.</li>
<li>see: merge — Returns the convergence of both values.</li>
<li>type: (@Either(a, b), *throws) => Unit -> b</li>
<li>throws: TypeError — if the monad doesn't have a <code>Right</code> value.</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">get: </span><span class="nf">-&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-get-or-else">Function: get-or-else</h4>

<p>Extracts the <code>Right</code> value out of the <code>Either(a, b)</code> monad. If
the monad doesn't have a <code>Right</code> value, returns the given default.
+ type: (@Either(a, b)) => b -> b</p></div></div><div class="code"><div class="wrapper">  <span class="nv">get-or-else: </span><span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-or-else">Function: or-else</h4>

<p>Transforms a <code>Left</code> value into a new <code>Either(a, b)</code> monad. Does
nothing if the monad contains a <code>Right</code> value.
+ type: (@Either(a, b)) => (a -> Either(c, b)) -> Either(c, b)</p></div></div><div class="code"><div class="wrapper">  <span class="o">or-</span><span class="k">else</span><span class="o">:</span> <span class="nf">(_) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-merge">Function: merge</h4>

<p>Returns the value of whichever side of the disjunction that is
present.
+ type: (@Either(a, a)) => Unit -> a</p></div></div><div class="code"><div class="wrapper">  <span class="nv">merge: </span><span class="nf">-&gt;</span> <span class="nx">@value</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h3 id="folds-and-extended-transformations">Folds and Extended Transformations</h3></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-fold">Function: fold</h4>

<p>Catamorphism. Takes two functions, applies the leftmost one to the
<code>Left</code> value and the rightmost one to the <code>Right</code> value, depending
on which one is present.
+ type: (@Either(a, b)) => (a -> c) -> (b -> c) -> c</p></div></div><div class="code"><div class="wrapper">  <span class="nv">fold: </span><span class="nf">(f, g) --&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-swap">Function: swap</h4>

<p>Swaps the disjunction values.</p>

<ul>
<li>type: (@Either(a, b)) => Unit -> Either(b, a)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">swap: </span><span class="nf">-&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-bimap">Function: bimap</h4>

<p>Maps both sides of the disjunction.
+ type: (@Either(a, b)) => (a -> c) -> (b -> d) -> Either(c, d)</p></div></div><div class="code"><div class="wrapper">  <span class="nv">bimap: </span><span class="nf">(f, g) --&gt;</span> <span class="p">...</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h4 id="function-left-map">Function: left-map</h4>

<p>Maps the left side of the disjunction.</p>

<ul>
<li>type: (@Either(a, b)) => (a -> c) -> Either(c, b)</li>
</ul></div></div><div class="code"><div class="wrapper">  <span class="nv">left-map: </span><span class="nf">(f) -&gt;</span> <span class="p">...</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="class-righta">Class: Right(a)</h2>

<p>Represents the <code>Right</code> side of the disjunction.</p></div></div><div class="code"><div class="wrapper"><span class="k">class</span> <span class="nx">Right</span> <span class="k">extends</span> <span class="nx">Either</span>
  <span class="nf">(@value) -&gt;</span>
  <span class="o">is-</span><span class="nv">right: </span><span class="kc">true</span>
  <span class="nv">ap: </span><span class="nf">(b) -&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">map</span> <span class="nx">@value</span>
  <span class="nv">map: </span><span class="nf">(f) -&gt;</span> <span class="nx">@</span><span class="k">of</span> <span class="p">(</span><span class="nx">f</span> <span class="nx">@value</span><span class="p">)</span>
  <span class="nv">chain: </span><span class="nf">(f) -&gt;</span> <span class="nx">f</span> <span class="nx">@value</span>
  <span class="k">to</span><span class="o">-</span><span class="nv">string: </span><span class="nf">-&gt;</span> <span class="s">&quot;Either.Right(</span><span class="si">#{</span><span class="nx">@value</span><span class="si">}</span><span class="s">)&quot;</span>
  <span class="o">is-</span><span class="nv">equal: </span><span class="nf">(a) -&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">is-right</span> <span class="o">and</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">is</span> <span class="nx">@value</span><span class="p">)</span>
  <span class="nv">get: </span><span class="nf">-&gt;</span> <span class="nx">@value</span>
  <span class="nv">get-or-else: </span><span class="nf">(_) -&gt;</span> <span class="nx">@value</span>
  <span class="o">or-</span><span class="k">else</span><span class="o">:</span> <span class="nf">(_) -&gt;</span> <span class="k">this</span>
  <span class="nv">fold: </span><span class="nf">(_, g) -&gt;</span> <span class="nx">g</span> <span class="nx">@value</span>
  <span class="nv">swap: </span><span class="nf">-&gt;</span> <span class="k">new</span> <span class="nx">Left</span><span class="p">(</span><span class="nx">@value</span><span class="p">)</span>
  <span class="nv">bimap: </span><span class="nf">(_, g) -&gt;</span> <span class="k">new</span> <span class="nx">Right</span><span class="p">(</span><span class="nx">g</span> <span class="nx">@value</span><span class="p">)</span>
  <span class="nv">left-map: </span><span class="nf">(_) -&gt;</span> <span class="k">this</span>
  </div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="class-lefta">Class: Left(a)</h2>

<p>Represents the <code>Left</code> side of the disjunction.</p></div></div><div class="code"><div class="wrapper"><span class="k">class</span> <span class="nx">Left</span> <span class="k">extends</span> <span class="nx">Either</span>
  <span class="nf">(@value) -&gt;</span>
  <span class="o">is-</span><span class="nv">left: </span><span class="kc">true</span>
  <span class="nv">ap: </span><span class="nf">(b) -&gt;</span> <span class="nx">b</span>
  <span class="nv">map: </span><span class="nf">(_) -&gt;</span> <span class="k">this</span>
  <span class="nv">chain: </span><span class="nf">(_) -&gt;</span> <span class="k">this</span>
  <span class="k">to</span><span class="o">-</span><span class="nv">string: </span><span class="nf">-&gt;</span> <span class="s">&quot;Either.Left(</span><span class="si">#{</span><span class="nx">@value</span><span class="si">}</span><span class="s">)&quot;</span>
  <span class="o">is-</span><span class="nv">equal: </span><span class="nf">(a) -&gt;</span> <span class="nx">a</span><span class="p">.</span><span class="nx">is-left</span> <span class="o">and</span> <span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">value</span> <span class="o">is</span> <span class="nx">@value</span><span class="p">)</span>
  <span class="nv">get: </span><span class="nf">-&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">TypeError</span><span class="p">(</span><span class="s">&quot;Can&#39;t extract the value of a Left(a)&quot;</span><span class="p">)</span>
  <span class="nv">get-or-else: </span><span class="nf">(a) -&gt;</span> <span class="nx">a</span>
  <span class="o">or-</span><span class="k">else</span><span class="o">:</span> <span class="nf">(f) -&gt;</span> <span class="nx">f</span> <span class="nx">@value</span>
  <span class="nv">fold: </span><span class="nf">(f, _) -&gt;</span> <span class="nx">f</span> <span class="nx">@value</span>
  <span class="nv">swap: </span><span class="nf">-&gt;</span> <span class="k">new</span> <span class="nx">Right</span><span class="p">(</span><span class="nx">@value</span><span class="p">)</span>
  <span class="nv">bimap: </span><span class="nf">(f, _) -&gt;</span> <span class="k">new</span> <span class="nx">Left</span><span class="p">(</span><span class="nx">f</span> <span class="nx">@value</span><span class="p">)</span>
  <span class="nv">left-map: </span><span class="nf">(f) -&gt;</span> <span class="k">new</span> <span class="nx">Left</span><span class="p">(</span><span class="nx">f</span> <span class="nx">@value</span><span class="p">)</span></div></div></div><div class="segment"><div class="comments "><div class="wrapper"><h2 id="exports">Exports</h2></div></div></div><div class="segment"><div class="code"><div class="wrapper"><span class="nv">module.exports = </span><span class="k">new</span> <span class="nx">Either</span></div></div></div></div></body></html>